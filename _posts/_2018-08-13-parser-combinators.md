---
title: Комбинаторы парсеров на Sprache
header:
teaser: images/about/beer.png
excerpt: Напишем вместе несколько парсеров без бойлерплейта
date: '2018-08-13 00:00:00'
toc: true
toc_label: "Содержание"
---

Разработчики иногда сталкиваются с задачей разобрать текст (распарсить) в структурированном формате и извлечь из него полезную информацию. Примеры того, что можно парсить — JSON, текст с датой и временем, исходный код на любом языке программирования.

Парсинг (особенно популярных форматов) — [не та задача, которую нужно программировать самостоятельно](https://blog.newrelic.com/engineering/7-things-never-code/). Поэтому каждый программист должен написать несколько парсеров — чтобы повеселиться и никогда так больше не делать, конечно же.

В этой статье расскажу, как можно легко написать свой парсер с помощью библиотеки [Sprache](https://github.com/sprache/Sprache).

## Почему не стоит писать свой парсер

В одном из домашних проектов потребовалось отфильтровать архив текстов, содержащих определенные слова. Условия оказалось удобно задавать в виде фильтров, похожих на [Must/Should](https://www.elastic.co/guide/en/elasticsearch/guide/current/combining-filters.html) из Elastic Search. Фильтр `Must` требует, чтобы все слова встретились в тексте, `Should` — хотя бы одно. Из простых условий с помощью `Must` и `Should` можно комбинировать сложные.

Условия для фильтра задаются текстом в таком виде:

```
(
    [Греция, Салоники, Родос],
    [Лиссабон, Порту, Португалия],
    Дублин
)
```

Слова для фильтрации разделяются запятыми. Условие `Must` заключается в круглые скобки, `Should` - в квадратные.

Фильтр можно описать простой грамматикой (в форме [БНФ](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form)):
```
<word> := <letter> | <letter><word>
<list> := <word> | <word>,<list>
<should> := [<list>]
<must> := (<list>)
<expr> := <word> | <must> | <should>
```

Проще простого! Давайте напишем наивную реализацию парсера. Для этого воспользуемся дедовским подходом, который выручал еще на парах по алгоритмам в университете:
- Запомним текущее слово. Будем дописывать к нему новый символ, если встретим его (и символ не будет скобкой или запятой);
- Заведем стек для запоминания последовательности открытых скобок;
- Вместе с открытой скобкой будем хранить список из построенных фильтров внутри этой скобки.

Реализацию можно посмотреть [на github](https://github.com/BurlakovNick/SpracheExamples/blob/master/Parsers/ParserExamples/Example1/NaiveFilterParser.cs):

```csharp
public static IFilter BuildFromText(string text)
{
    var stack = new Stack<(char, List<IFilter>)>();
    var word = new List<char>();

    stack.Push(('@', new List<IFilter>()));

    foreach (var ch in text)
    {
        if (char.IsWhiteSpace(ch))
        {
            continue;
        }

        if (ch == ')' || ch == ']')
        {
            Pop(ch);
            continue;
        }

        if (ch == '(' || ch == '[')
        {
            Push(ch);
            continue;
        }

        if (ch == ',')
        {
            ClearWord();
            continue;
        }

        word.Add(ch);
    }

    ClearWord();

    return stack.Peek().Item2.First();

    void ClearWord()
    {
        if (word.Count > 0)
        {
            stack
             .Peek()
             .Item2
             .Add(new WordFilter(
                 new string(word.ToArray())
                 ));
        }

        word.Clear();
    }

    void Push(char ch)
    {
        ClearWord();
        stack.Push((ch, new List<IFilter>()));
    }

    void Pop(char ch)
    {
        ClearWord();

        if (!stack.TryPop(out var top))
        {
            throw new Exception(
                $"stack is empty, expected = {ch}"
                );
        }

        var expected = ch == ')' ? '(' : '[';
        if (top.Item1 != expected)
        {
            throw new Exception(
                $"on top of stack is {top}, expected = {ch}"
                );
        }

        var newFilter = ch == ')'
            ? (IFilter) new MustFilter(top.Item2)
            : new ShouldFilter(top.Item2);

        stack.Peek().Item2.Add(newFilter);
    }
}
```

Мерлинова борода! Получилось не так-то просто. В наивном подходе я вижу несколько проблем:
- Код парсера лапшеобразный, в него страшно добавлять новые фичи;
- Есть несколько крайних случаев, которые легко пропустить (модульными тестами я отловил 3 бага перед тем, как этот код заработал);
- И код совершенно не отображает грамматику, которую мы разбираем.

Но ведь грамматика языка простая! Не должно быть так сложно. Хочется получить парсер автоматически, просто скормив машине описание грамматики. Можно ли так сделать? Оказывается, можно!



---

План:
- Проблема - хочется распарсить какую-то грамматику. 
    - Пример из домашнего проекта - скобочная последовательность.
    - Наивная реализация - куча бойлерплейта
    - БНФ. А можно ли как-то похожим образом это сделать? Максимально декларативно?
- Окей, вспомним про монады
    - Maybe. Пример с парсингом строки, а из нее подстроки, и так далее
    - Что такое монада? 
    - Монада парсера


```csharp
Parser<T> = Func<Input, Result<T>>
Result<T>
	bool Success
    Input Remaining
    T ParsedValue
```

- Sprache
    - Примитивные парсеры
    - Комбинаторы

- Пример со скобочными последовательностями
    - Как выглядит код
        - TriggerList
        - Word
        - List
            - Что такое Ref
        - Should/Must
        - Expr
            - Что такое XOR, разница с OR
    - Бенчмарк

- Пример с DSL.
    - Предметная область - формирование юридических документов по набору правил при заключении сделки в Биллинге
    - Как выглядит логика - на человеческом языке
    - Проблема
        - Новые правила появляются постоянно
        - Разработчик руками пишет кучу однообразного кода
        - Давайте сделаем DSL и отдадим кому-то еще!

- Другие инструменты